### Java SE
#### 集合
##### [[ArrayList实现原理]]
1. ArrayList底层是一个数组，当数组中元素的数量超过一定限度就进行扩容。

##### [[LinkedList实现原理]]
1. LinkedList基于节点 Node 实现，每个Node中有指向前后Node指针。

##### [[HashMap实现原理]]
1. HashMap的核心原理是Hash、取模，对象经过Hash得到哈希码，再经过取模将对象映射到一个特定的范围内，实现从大范围到小范围的映射。比如说这个范围是16，那么最后哈希取模后的结果都会落在0-15中，寻找对象时就可以通过哈希取模直接定位到对象的位置，
2. 但如果元素数量增多就会造成两个问题，
	1. 一个问题是多个对象的Hash取模结果相同，也就是哈希冲突的问题。
	2. 第二个问题是HashMap中数量太多导致HashMap退化成链表，也就是哈希表扩容的问题。
	3. 在Java中解决Hash冲突的方法是链地址法在JDK1.7采用链表存储相同结果的元素，而在JDK1.8进一步优化，采用了链表/红黑树结合方式，链表元素数量大于8时将链表变为红黑树，提高查询效率。同时在JDK1.8用尾插法替代了JDK1.7的头插法，避免了循环链表的问题。
	4. 对于扩容的问题，当HashMap的元素数量超过了HashMap容积和负载因子的乘积后进行扩容，在JDK1.7中，每次扩容我们都需要重新进行Hash计算，但JDK1.8可以直接通过位运算确定位置。

#### String
##### [[String为什么不可变]]
因为String在Java中被大量使用，将String设为不可变的可以将String缓存起来，让多个对象使用一份String，并且不需要考虑数据一致性的问题。同时在多线程的场景下，由于不可变，String也是线程安全的，访问的时候不需要考虑线程安全问题，提升了性能。

##### [[intern()的原理]]
1. 如果String在字符串常量池中，就返回这个字符串常量池中字符串的引用
2. 如果String不在字符串常量池中，则将字符串放入字符串常量池，返回字符串常量池中字符串的引用

##### [[字符串常量池_运行时常量池_类常量池之间的联系]]
1. 每一个Class都有一个类常量池
2. 运行池常量池中包含了字面量、符号引用、方法/接口引用
3. 字符串存储在类常量池中，在运行时被加载到字符串常量池中

##### [[字符串进入字符串常量池的时机]]
1. 字符串存储在类常量池中，在运行时被加载到字符串常量池中
2. 代码中intern()将字符串放入字符串常量池

#### [[Java对象结构]]
1. 对象头
	1. MarkWord 保存对象实例信息
	2. Klass Word指向方法区中类的信息
2. 对象体
3. 对齐字节