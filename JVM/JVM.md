#### JVM内存区域

##### [[介绍一下JVM的内存区域]]
1. 线程共享
	1. 堆
	2. 方法区
		1. 在JDK1.6、1.7中由永久代实现
		2. 在JDK1.8由元空间实现，避免了元空间的内存溢出问题，并且元空间存储在直接内存中
2. 线程私有
	1. 程序计数器
	2. 虚拟机栈
	3. 本地方法栈
3. 在JDK1.6中字符串常量池在方法区中，JDK1.7以后移到堆中


##### [[jdk1.8内存结构]]
1. 线程私有
	1. 程序计数器
	2. 虚拟机栈
	3. 本地方法栈
2. 线程共享
	1. 字符串池在堆中
	2. 方法区由元空间实现
	3. 元空间存储在直接内存，避免了永久代内存溢出的问题
##### [[class信息在哪个区]]
1. 方法区
##### [[类文件的结构]]
1. 对象头
	1. Mark Word
	2. Klass Word 
2. 数据
3. 对齐字节
##### [[什么是内存泄漏，什么时候发生]]
1. 内存无法被回收
2. 非静态内部类和匿名类会持有外部类的引用
3. ThreadLocal
4. 未关闭的资源（如文件、数据库连接、网络连接等）导致内存泄漏
5. 线程池中的线程持有的对象引用可能导致内存泄漏
##### [[元空间会内存泄漏吗]]
1. 会的
2. 类加载器泄漏：
    - 类加载器（ClassLoader）持有对类元数据的引用，如果类加载器不能被及时回收，就会导致元空间中的类元数据无法被释放，进而导致内存泄漏。
2. 动态生成类：
    - 如果应用程序频繁生成动态类（例如大量使用反射或动态代理），这些类会占用元空间，如果生成的类没有及时卸载，也会导致内存泄漏。
3. 框架和库：
    - 某些框架和库可能会缓存类元数据，导致这些类无法被及时回收，从而导致元空间内存泄漏。
##### [[垃圾回收哪几个步骤要stop the world]]
1. 初始标记
2. 重写标记
3. 回收对象、易懂对象



#### 垃圾回收
##### [[介绍一下JVM的垃圾回收器]]
**按回收区域分**
1. 新生代垃圾回收器
	1. Serial New
	2. ParNew
	3. Parallel Scavenge
	4. 都基于标记-复制
2. 老年代垃圾回收器
	1. Serial Old
		1. 标记整理
	2. Parallel Old
		1. 标记整理
	3. CMS
		1. 标记清除，三色标记
3. 整堆垃圾回收器
	1. G1
		1. 标记-复制新生代
		2. 标记-整理老年代
		3. 三色标记
	2. ZGC
按串并行分
1. 串行
	1. Serial New
	2. Serial Old
2. 并行
	1. ParNew
	2. Parallel Scavenge
	3. Parallel Old
	4. G1
	5. CMS
	6. ZGC
##### [[介绍一下垃圾回收算法]]
1. 标记-清除
2. 标记-复制
3. 标记-整理

##### [[介绍一下JVM怎么进行存活对象分析]]
1. 引用计数
2. 可达性分析


##### [[JVM是怎么进行内存分配的]]
1. 先把对象分配在新生代
2. 如果大小过大，直接进入老年区
3. 后续每一次gc时记录年龄
4. 达到年龄的进入老年区
5. 同时还会进行动态的调整，某个年龄所有对象大小大于survivor区一半时，大于这个年龄的对象都进入老年区
##### [[G1的本身瓶颈在哪]]
 1. **预测模型不准确**
G1垃圾收集器依赖于垃圾回收预测模型来确定收集的时间和区域。然而，预测模型并不总是准确的，尤其是在应用程序内存使用模式复杂或变化较大的情况下。这可能导致垃圾收集的暂停时间超过预期。
2. **高开销的并发标记**
G1在进行并发标记阶段时，虽然不会完全停止应用程序线程，但仍然会消耗一定的CPU资源。对于高CPU负载的应用，这种开销可能会影响应用程序的性能。
3. **卡片表开销**
G1使用卡片表(Card Table)来跟踪引用更新，但这会增加额外的内存和处理开销。特别是在内存使用密集的应用程序中，卡片表的维护可能会成为瓶颈。
4. **混合回收效率**
混合回收阶段（Mixed GC）中，G1不仅回收年轻代（Young Generation），还会回收部分老年代（Old Generation）。但是，如果应用程序的老年代增长较快，混合回收可能无法跟上，导致Full GC频率增加，进而影响性能。
5. **暂停时间不确定**
尽管G1的设计目标是低延迟，但在某些情况下，尤其是当内存碎片化严重时，暂停时间可能会变得不确定，甚至超过预期的目标暂停时间。
6. **内存碎片化**
G1通过分区（Region）的方式管理堆内存，但这种方式可能会导致内存碎片化问题。内存碎片化会导致内存利用率下降，从而需要更多的GC来回收这些碎片，影响应用性能。
7. **Full GC开销**
虽然G1设计的目的是尽量避免Full GC，但在一些极端情况下（如内存非常紧张或老年代增长过快）仍可能触发Full GC。G1的Full GC是单线程的，停顿时间较长，对应用影响较大。
8. **初始标记和并发标记**
G1的初始标记阶段会暂停所有应用线程，尽管时间较短，但在高并发应用中可能仍会成为瓶颈。而并发标记阶段虽然不暂停应用线程，但会增加额外的CPU开销，影响应用性能。
9. **复杂的调优**
G1垃圾收集器的调优参数较多，调优过程复杂。需要对应用的内存使用模式有深入了解，并进行多次试验和调整，才能达到最佳效果。
##### [[完整的垃圾回收流程]]
#### 类加载
##### [[类的加载时机]]
1. new 对象
2. 访问类静态变量
3. 给类的静态变量赋值
4. 调用静态类方法
5. 初始化子类时，父类还未初始化，先初始化父类
6. 反射使用静态类
7. 虚拟机启动时的主类
7. default修饰的接口实现类初始化，该接口要在其之前初始化

##### [[类加载分几个阶段]]
1. 加载
	1. 查找和导入类的二进制数据
	2. 将二进制数据转换为方法区的数据结构
	3. 在内存中生成一个Class对象
2. 链接
	1. 验证
		1. 确保字节码符合JVM规范
	2. 准备
		1. 为类的静态变量分配内存，并初始化默认值
	3. 解析
		1. 将常量池的符号引用转换为直接引用
3. 初始化
	1. 执行<clinit\>方法

##### [[链接的几个步骤]]
1. 验证
2. 准备
3. 解析
##### [[初始化阶段的顺序]]
初始化阶段是执行类构造器`<clinit>`方法的过程。
`<clinit>`方法是由编译器自动收集类中的所有类变量的赋值动作和静态语句中的语句合并产生的，编译器收集的顺序是由语句在源文件中出现的顺序所决定的
虚拟机会保证在子类的`<clinit>`方法执行之前，父类的`<clinit>`方法已经执行完毕。 因此在虚拟机中第一个被执行的`<clinit>`方法的类肯定是java.lang.Object。意味着父类中定义的静态语句块要优先于子类的变量赋值操作
##### [[类的卸载时机]]
类的卸载条件：
1. 类加载器实例被回收。
2. 没有活动的实例。
3. 没有活动的线程在执行这些类中的代码。
4. 没有对类的引用。
卸载时机：
1. 类加载器被回收
2. Full GC
##### [[介绍一下双亲委派的规则]]
1. 加载类时先递归检查父加载器有没有加载
2. 如果父加载器没有加载当前加载器进行加载
##### [[为什么要有双亲委派机制]]
1. **类的重复加载问题**：通过将类加载请求逐级向上委派，确保了同一个类不会被重复加载。这样可以避免重复加载同一个类所带来的内存浪费和潜在的类冲突问题。
2. **核心类库的安全性问题**：双亲委派机制确保了核心类库（如 `java.lang.Object` 等）只能由顶层的启动类加载器加载，从而避免了应用程序加载器对这些核心类库进行篡改。这保证了 Java 核心类库的安全性和稳定性。
3. **类的版本一致性问题**：通过双亲委派机制，不同类加载器加载的类可以保持版本一致性，避免了同一个类的多个版本在 JVM 中共存而引起的不一致性问题。
##### [[类被重复加载会有什么问题]]
1. 方法区内存溢出
2. 找不到对应的类


##### [[对象从new到销毁之间经历的过程]]
1. 先检查类有没有被加载
2. 如果没有加载先进行类的加载
3. 再为对象分配内存，一般分配堆内存，也有可能分配在栈上
	1. 放入新生代eden区
	2. eden放不下放survivor区
	3. survivor放不下放老年代
	4. 对象过大，直接放入老年代
4. 初始化默认值
5. 调用构造方法
6. 正式使用
7. 可达性分析
8. 进行垃圾回收

##### [[如何实现类的热更新]]
1. 类字节码替换
这是Java中常用的热更新方法。它涉及到以下步骤：
- 加载新的类字节码：通过类加载器加载新的类字节码。
- 替换旧的类字节码：使用反射或字节码操作框架（如Javassist，ASM）动态替换旧的类实现。
2. 动态代理
通过动态代理，可以在运行时创建新的类实例，代理旧的类方法调用。这种方法可以实现某些特定方法的热更新，而不需要替换整个类。
3. 插件化架构
将应用程序的某些功能模块化，通过插件机制加载和卸载模块。这使得特定功能模块可以在运行时更新或替换。
4. 热部署（Hot Deployment）
在Web应用中，热部署是一种常见的热更新技术。它允许在不重新启动服务器的情况下，部署新的Web应用或更新现有的Web应用。大多数现代的应用服务器（如Tomcat、Jetty）都支持热部署。

1. 发布事件
2. 重新注册/替换Bean
##### [[父子加载器之间的关系]]
组合
##### [[怎么破坏双亲委派机制]]
重写loadClass方法