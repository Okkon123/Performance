**核心线程数**
1. CPU密集型
	1. 线程数 ～ CPU核数
2. IO密集型
	1. 线程数 ～ CPU核数 * 2
3. CPU一直执行指令，利用率100%，但是有外部调用/IO时，有等待，利用率达不到100%，此时可以切换线程
**最大线程数**
1. 
**阻塞队列**
1. **ArrayBlockingQueue**：
   - 特点：一个基于数组的有界阻塞队列，按 FIFO（先进先出）原则对元素进行排序。
   - 适用场景：适用于任务处理时间较为均匀的场景，能够提供较高的吞吐量。
2. **LinkedBlockingQueue**：
   - 特点：一个基于链表的无界阻塞队列（可以指定容量），按 FIFO 排序。可以在高并发场景下提供更好的性能。
   - 适用场景：适用于任务处理时间不均匀的场景，队列长度不容易确定时可以使用无界队列。
3. **SynchronousQueue**：
   - 特点：一个不存储元素的阻塞队列，每个插入操作必须等待另一个线程的移除操作，反之亦然。
   - 适用场景：适用于任务提交速度和处理速度接近的场景，如短期内需要快速处理大量任务。
4. **PriorityBlockingQueue**：
   - 特点：一个支持优先级排序的无界阻塞队列，元素按照优先级顺序排序。
   - 适用场景：适用于需要按照优先级处理任务的场景，如任务有明显的优先级区分
5. **DelayQueue**：
   - 特点：一个支持延时获取元素的无界阻塞队列，只有到期的元素才能从队列中取出。
   - 适用场景：适用于需要延时处理的任务，如定时任务调度。
选择阻塞队列的建议：
1. **任务特性**：
   - 任务处理时间较为均匀时选择 `ArrayBlockingQueue` 或 `LinkedBlockingQueue`。
   - 任务有优先级需求时选择 `PriorityBlockingQueue`。
   - 需要延时处理的任务选择 `DelayQueue`。
2. **系统负载**：
   - 系统负载较大时，选择有界队列（如 `ArrayBlockingQueue`）以防止内存溢出。
   - 系统负载较小且任务不确定时，选择无界队列（如 `LinkedBlockingQueue`）以提高吞吐量。
3. **吞吐量和延迟**：
   - 需要高吞吐量时选择 `ArrayBlockingQueue`。
   - 需要低延迟时选择 `SynchronousQueue`。
通过合理选择和配置阻塞队列，可以有效提升线程池的性能和系统的整体稳定性。
**非核心线程数存活时间**
1. 
**非核心线程数存活时间单位**
**创建线程工厂**
**拒绝策略**
1. 