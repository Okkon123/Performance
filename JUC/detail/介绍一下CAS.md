1. CAS 操作包含三个操作数 —— 内存位置（V）、预期原值（A）和新值(B)。在进行并发修改的时候，会先比较A和V中取出的值是否相等，如果相等，则会把值替换成B，否则就不做任何操作。
2. CAS底层依赖Unsafe类，直接对底层数据进行修改，在CPU层面以来cmpxchg指令，实现操作的原子性
3. CAS摒弃了传统的锁机制，避免了因获取和释放锁产生的上下文切换和线程阻塞，但是，在高并发条件下，频繁的CAS操作可能导致大量的自旋重试，消耗大量的CPU资源，所以CAS不适合特别高并发的场景。