1. 锁的粒度
	JDK 1.7: 使用了分段锁（Segment），`ConcurrentHashMap` 由多个 Segment 组成，每个 Segment 其实是一个小的 `HashMap`
	JDK 1.8: 取消了分段锁，改用 CAS（Compare-And-Swap）和 `synchronized` 来保证并发安全。锁的是一个操
2. 数据结构
	JDK 1.7: 使用数组 + 链表的结构
	JDK 1.8: 使用数组 + 链表 + 红黑树的数据结构
3. 并发性能
	JDK 1.7: 由于采用分段锁机制，在高并发场景下，锁竞争相对较少，但在某些极端情况下，分段锁机制可能无法充分发挥多线程优势。
	JDK 1.8:  通过 CAS 和 `synchronized` 细粒度锁控制，减少了锁竞争，提高了并发性能。特别是在高并发场景下，性能提升显著。

4. 扩容机制
	JDK 1.7: 扩容时，整个 Segment 需要加锁，扩容的过程是阻塞的。
	JDK 1.8: 扩容时，使用了一种分段迁移的机制，允许多个线程同时进行扩容操作，减少了扩容时的性能瓶颈。
5. 代码复杂度
	JDK 1.7: 由于使用了分段锁机制，代码相对复杂，维护成本较高。
	JDK 1.8: 使用了更简单的 CAS 和 `synchronized` 机制，代码结构更加清晰，维护成本降低。