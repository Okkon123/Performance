
亮点：高并发，数据量大、技术牛、业务牛、大数据量
数据量的演变过程
```
慢sql 优化索引 分表(水平拆分，垂直拆分，关联查询的问题) 分布式数据库(单机I/O瓶颈) 
主从/分片
```
使用json序列化器对敏感数据加密
生成短链接(当前时间 + UUID ---哈希算法---> 六位short_uri)，创建短链接时将其加入到redis中
分表
跳转逻辑 (布隆过滤器，双重判定锁，缓存穿透)


布隆过滤器场景：
1. 用户是否存在
2. 创建短链接时将短链接加入布隆过滤器
3. 

场景：
用户海量注册


问题：
1. 创建短链接延迟高，问题出在获取图标
2. 更新短链接


面试官您好，我叫左杰，就读于重庆大学计算机专业，现大三，这次想面试的岗位是后端开发实习生，主要的是技术栈是SSM、SpringBoot、MyBatis、MyBatisPlus、MySQL、Redis、Linux、git，对技术有浓厚的兴趣，有自学国外公开课的经历。性格真诚友善，能和他人良好沟通，具备出色的合作能力和抗压能力，能够倾听他人意见并促进团队协作，完成共同目标，平时的爱好是打羽毛球。

很多企业都有通过将网址发送给用户让用户使用相关功能的需求，常见的场景有拼多多、淘宝分享商品链接、企业发送营销短信，我这个项目的核心功能就是将原本的长链接转变为短链接，同时记录这个链接的访问数据。听起来可能没什么实际意义，但是通过我的项目可以追踪短链接的访问情况，了解用户的行为和喜好，这些数据对企业来说是很有价值的。同时在短信、微博等限制字符数的特殊场景下，通过短链接可以节省空间，更加美观。

这个项目主要使用了SpringBoot、RocketMQ、ShardingSphere、Redis、MySQL、MyBatisPlus、Sentinel等技术。

从业务上来说主要有四个功能：
1. 用户服务，包含了用户登陆注册以及个人信息查看功能
2. 分组服务，包含短链接分组的增删改查，在项目中一个用户有多个短链接分组，一个分组内有多个短链接
3. 短链接服务，包含短链接创建、修改、跳转功能
4. 监控服务，包含了记录查询短链接访问数据的功能

业务中比较核心的表有短链接表、短链接路由表、访问日志表。短链接表核心的字段有分组ID、原始链接、原始链接对应的短链接。最开始使用的单表，但是考虑到数据量会不断增大导致查询速度过慢，所以考虑分表，又因为短链接表中的字段大部分比较常用所以最后使用了水平分表，将短链接表水平分为了16个表，通过ShardingSphere组件实现分表的增删改查，最后选用了分组ID作为分片键。但是在后续实现短链接跳转时又出现了新的问题，因为用户通过短链接来获取原始链接，而短链接表通过分组ID分片，用户只通过短链接获取原始链接会造成读扩散问题，所以新增了一个短链接路由表，主要字段为短链接、分组ID。所以获取原始链接的流程是先查询路由表获取分组ID，再根据分组ID和短链接查询短链接表获取原始链接。同时为了提高查询速度我在短链接表和路由表的短链接字段上建立了唯一索引。访问日志表记录了访问的次数、地区、时间、IP、访问设备等信息。

项目中最核心的的功能是短链接跳转原始链接，原理是将用户的请求重定向到原始链接。当用户访问短链接时，通过短链接拿到原始链接。作为项目的核心功能，这个接口会被大量访问。

假设短链接被发送到微博上，很多人访问这个短链接。如果这些请求直接打到数据库，容易导致数据库崩溃，所以在这里我使用了redis作为缓存，降低数据库的压力。但也存在redis缓存失效的情况，如果有人恶意大量的请求一个不存在的短链接，那么这些请求会直接打到数据库中，造成数据库崩溃，这也就是常见的**缓存击穿**问题。对于这个问题有三种比较常见的解决方案，一是**缓存空对象**，如果请求的数据在数据库中不存在就会缓存一个空值在redis中，防止这些请求直接打到数据库，这种方式实现比较简单，维护也很方便，但是内存消耗比较大。二是使用**布隆过滤器**，请求发送过来时在redis层面验证数据是否存在，这种方案内存的占用少，但实现和维护都比较复杂，并且有误判可能。三是使用**分布式锁**，只让一个请求访问数据库，其他请求等待，但这种方案用户等待时间过长，会造成用户的体验不好。我的解决方案结合了这三种方案，首先使用布隆过滤器判断请求的短链接是否存在，因为布隆过滤器存在误判可能，如果用户恰好一直请求不存在的商铺信息并且被布隆过滤器误判为存在，这样的话还是会导致缓存穿透的情况，而如果我在布隆过滤器后再加一层缓存空对象，那么就算布隆过滤器误判，也能被很好的解决，但在极端的情况下，大量被误判的请求被打到数据库中，此时redis中也未缓存空对象，那么这些数据最后还是会被打到数据库中，所以最后我还使用了**双重判定锁**，只让一个请求访问数据库，并为不存在的数据在redis中缓存空值，后续其他的请求获取锁后再次查询redis，获取空值，直接返回不会再次访问数据库。同时这个方案也很好地解决了热点key过期时，大量请求打到数据库中的情况，即**缓存击穿**问题。

单个短链接不存在或过期的情况很好的解决了，但假设大量短链接缓存同时失效，也会造成大量请求直接打到数据库，也就是**缓存雪崩**的问题，我的解决方案是再设置缓存时在原有的ttl上添加一个随机值，降低大量key同时失效的概率，将这些同时访问数据库的请求均分到一段时间中，降低了数据库的压力。

如果用户修改短链接时，同时有人访问此短连接，很容易出现用户获取到的数据和实际数据不一致的情况，也就是**缓存一致性**的问题。我的解决方案是先操作数据库再删除缓存，这种方案虽然也有出现数据库缓存不一致的情况，但由于此功能对数据不敏感，并且redis操纵内存中的数据速度较快，出现数据库缓存不一致的概率很小，但如果采用加锁保证缓存一致性的话，性能较低，得不偿失。如果后续有需要可以升级为Canal配合Binlog解决缓存一致性的问题。

项目中另一个核心功能就是记录用户的访问数据，当用户访问短链接时，获取用户的访问信息、如访问IP、访问设备、访问源地址等，插入数据库对应表中，而若此功能同步进行，先记录数据，再重定向的话，那么接口的性能会遭到很大的影响，并且当有大量请求时，数据库无法承受海量的调用，甚至会导致数据库宕机。所以我在这里使用了RocketMQ分离记录访问信息和重定向的逻辑，进行削峰操作，异步的记录访问信息。同时还是用Redis完成了消息队列消费的幂等，保障消息在一定时间内消费且仅消费一次。(可拓展 为什么使用RocektMQ)

为了项目部署到公网后收到恶意攻击，项目通过Sentinel接口实现了限流风控，触发限流规则后降级处理。