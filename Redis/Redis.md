#### 整体架构
##### [[Redis为什么快]]
1. Redis基于内存，操作内存的速度快很多
2. Redis单线程，减少了上下文切换的损耗
3. 多路复用的 IO 方式
4. 后台处理重写
5. 渐进式rehash，减少阻塞
6. 惰性删除
##### [[redis除了内存之外还有什么优势]]
1. 单线程，减少上下文切换的损耗
2. 提供丰富的数据结构，使用简单
3. 持久化
4. 高可用，可以集群部署，分布式
5. 组件丰富，Redisson

#### 数据结构
##### [[redis渐进式哈希如何实现]]
1. 根据负载因子的大小决定什么时候开始rehash，扩容2倍，缩容两倍2倍。
2. 对旧hash表操作时都会顺便将数据更新到新表上，添加元素时，只添加到新表上
3. rehash完成后，将表1表2指针替换。
##### [[redis跳表的优势]]
1. 范围查询效率高
2. 插入删除效率高，不需要像红黑树一样旋转操作，维护成本低
3. 内存友好
##### [[zset用在什么场景]]
1. 排行榜
2. 任务调度
3. 延迟队列
4. 限流

#### 持久化
##### [[Redis怎么实现持久化]]
1. RDB，基于内存快照，快照时使用COW，快照时的操作无法持久化
2. AOF，基于命令，丢失数据少
3. RDB结合AOF，先快照，快照期间的操作用AOF，结合RDB 恢复速度快的优点， AOF 丢失数据少的优点

#### 过期删除/内存淘汰
##### [[介绍一下Redis的过期删除]]
1. 惰性删除
	1. 每次使用键值对时检查是否过期
2. 定期删除
	1. 隔一段时间从过期字典中取出20个键值对，检查是否过期，如果删除时间小于25ms并且删除的键值对大于25%则继续循环，否则退出。

##### [[介绍一下Redis的内存淘汰]]
1. 随机
2. 有过期时间
	1. 随机
	2. 根据过期时间淘汰
	3. 最近最少使用
3. 无过期时间
	1. 随机
	2. 最近最少使用
	3. 最近最久未使用
#### 集群
##### [[redis有哪些集群模式]]
1. 主从复制
2. 哨兵模式
3. 集群模式
4. 双活模式

##### [[redis的哨兵机制]]
哨兵会定期向主节点发送 PING 命令，检查主节点是否存活。如果主节点在指定的时间内没有响应，哨兵会认为主节点出现了故障。
当一个哨兵检测到主节点故障后，会与其他哨兵沟通，进行故障确认。如果大多数哨兵都认为主节点故障，才会开始故障转移流程。
在进行故障转移前，哨兵们需要选举出一个领导哨兵来负责故障转移的具体操作。选举过程使用 Raft 的选举算法，每个哨兵投票选举领导哨兵，得票最多者当选。
领导哨兵将选定的从节点提升为新的主节点，并将其他从节点重新配置为从新的主节点复制数据。同时，通知所有的哨兵和客户端新的主节点信息。
新的主节点会与其他从节点进行数据同步，确保数据的一致性。

##### [[redis在哨兵模式下如何解决脑裂问题]]
1. 设置主节点必须要多少个从节点
2. 设置主从通信消息的延迟时间

##### [[redis哨兵机制解决的问题]]
1. Redis 哨兵机制通过自动故障检测与恢复、主从节点切换、配置提供、系统监控与通知、分布式协调、自动化运维和数据一致性保障等功能，有效解决了 Redis 集群中的高可用性和可靠性问题，为 Redis 提供了强有力的高可用性解决方案。

#### 数据一致性
##### [[如何实现redis和DB之间的缓存一致性]]
**常见的解决方案**
1. 先更新数据库，再删除缓存
	1. 多线程并发
		1. 在之前没有缓存的情况下，可能导致数据不一致，但是概率比较小
	2. 操作原子性问题
		1. 更新数据库操作失败，不影响一致性
		2. 删除缓存失败，影响一致性，只能等到下一次更新或者缓存过期失效
	3. 缓存穿透风险
		1. 加锁，双重判定锁
2. 延迟双删，先删除缓存，再更新数据库，最后再删除缓存
	1. 多线程并发
		1. 在删除缓存和更新数据库期间进行读数据会造成数据不一致，通过延迟双删保证一致性
		2. 延迟删除的时间难以确定
	2. 操作原子性问题
		1. redis失败概率小
		2. 删除缓存失败，不影响一致性
		3. 更新数据库失败，不影响一致性
3. cache-aside，更新数据库，监听binlog进行缓存删除
**如何选择**
1. 如果业务量不大，并发不高的情况，可以选择先更新数据库，后删除缓存的方式，因为这种方案更加简单。  
2. 但是，如果是业务量比较大，并发度很高的话，那么建议选择先删除缓存，因为这种方式在引入延迟双删、分布式锁等机制会，会使得整个方案会更加趋近于完美，带来的并发问题更少。当然，也会更复杂。
**考虑网络带宽**
2. 先更新缓存再更新数据库 容易数据不一致
3. 先更新数据库再更新缓存 容易数据不一致
1. Cache-Aside 
	1. 先删缓存更新数据库
	2. 先更新数据库再删缓存
3. Read-Through / Write through
	1. 只更新缓存，同步更新数据库
4. Write behind
	1. 只操作缓存，异步更新数据库

##### [[如何保障redis和DB之间的强一致性]]

1. 使用消息队列
2. 分布式锁：在高并发场景下使用分布式锁（如 Redis 的 `SETNX` 命令）来保证数据的一致性。
3. 版本控制：通过版本号来控制数据的一致性，确保每次操作的数据版本是最新的。
4. 两阶段提交：使用两阶段提交协议来确保数据库和缓存的一致性。

#### 分布式锁

##### [[Redis如何实现分布式锁]]
1. setnx
##### [[进程持有分布式锁挂了，锁永远不会释放吗]]
1. 超时释放
2. 续期

##### [[redission解决了什么问题]]
1. 锁的高可用性
Redisson 通过在 Redis 集群或主从结构上实现分布式锁，确保即使某个 Redis 节点出现故障，锁也能够继续在其他节点上生效，从而提高了系统的可用性。
2. 防止死锁
Redisson 实现的分布式锁默认带有过期时间，即使持有锁的客户端出现故障，锁也会在过期时间后自动释放，避免死锁问题。
3. 锁续期机制
Redisson 提供了锁续期机制，可以在持有锁的客户端正常运行时不断续期，确保锁不会在业务逻辑执行过程中过期释放。这对于长时间持有锁的业务场景非常有用。
4. 公平锁
Redisson 支持公平锁，确保锁的获取是按请求的顺序进行的，避免了饥饿现象，保证了锁的公平性。
5. 可重入锁
Redisson 提供了可重入锁（Reentrant Lock），允许同一个线程多次获取同一把锁，且不会发生死锁现象。这对于递归调用和嵌套锁定的场景非常有用。
6. 红锁（Redlock）算法支持
Redisson 内部实现了 Redlock 算法，确保锁在分布式环境中的高可用性和一致性。Redlock 通过在多个独立 Redis 实例上加锁，确保即使部分实例出现故障，锁仍然是有效的。
7. 分布式条件变量
Redisson 提供了分布式条件变量（Condition），可以在分布式环境中使用类似 Java `Condition` 的功能，配合分布式锁进行线程协调。
8. 哨兵模式和集群模式支持
Redisson 支持 Redis 的哨兵模式和集群模式，确保在 Redis 节点故障时能够自动切换，提高了系统的可靠性和高可用性。
##### [[介绍一下redission的关门狗机制]]
1. 获取锁时会设置一个过期时间，同时启动一个独立的看门狗线程周期检查锁的状态，在锁过期前进行续期，延长锁的过期时间。任务完成后，主动释放锁。

##### [[分布式锁的使用场景]]
1. 资源竞争
在分布式系统中，多个节点可能会同时尝试访问共享资源，比如数据库记录、文件、缓存等。分布式锁可以确保在任意时刻，只有一个节点能够访问该资源，避免数据冲突和资源竞争。
2. 定时任务
在分布式环境中，存在多个定时任务服务实例时，使用分布式锁可以确保某个定时任务在同一时间只由一个实例执行，避免重复执行任务。
3. 分布式事务
在跨多个服务或数据库的分布式事务中，分布式锁可以确保在事务的各个阶段中，资源状态的一致性，防止出现数据不一致的情况。
4. 库存扣减
在电商系统中，多个请求可能会同时对库存进行扣减操作，通过分布式锁可以确保库存扣减的原子性，避免超卖问题。
5. 限流
在高并发访问某些关键接口时，可以使用分布式锁来控制并发请求的数量，防止系统过载。
6. 唯一ID生成
在分布式系统中生成全局唯一ID时，使用分布式锁可以确保ID的唯一性，防止生成重复ID。
7. 配置更新
在分布式系统中，更新共享配置时，通过分布式锁可以确保配置更新的原子性，防止多个节点同时更新导致的配置不一致。
8. 分布式缓存
在分布式缓存系统中，使用分布式锁可以确保缓存数据的一致性，避免缓存击穿、缓存雪崩等问题。
9. 任务调度
在分布式任务调度系统中，使用分布式锁可以确保任务在多个节点之间的调度和执行不会发生冲突。
10. 文件锁

##### [[RedLock解决了什么问题]]
1. 高可用性
在分布式系统中，单点故障是一个严重的问题。Redlock 通过在多个独立的 Redis 实例上尝试加锁，确保即使某个实例出现故障，锁仍然可以在其他实例上继续生效，从而提高了系统的可用性。
2. 时钟漂移问题
在分布式系统中，不同节点的时钟可能存在漂移。Redlock 通过计算锁的“偏移时间”，确保锁的持有时间是相对一致的，避免因时钟漂移导致的锁失效或过期等问题。
3. 防止死锁
Redlock 通过设置锁的过期时间，防止因客户端崩溃或网络分区导致的死锁问题。即使客户端在持有锁期间崩溃，锁也会在过期时间后自动释放。
4. 数据一致性
Redlock 通过在大多数（超过一半）实例上成功加锁，确保锁的获取是有效的，从而保证数据一致性。即使某些实例出现故障，只要大多数实例正常工作，锁仍然是有效的。
#### 杂
##### [[介绍一下lua脚本]]
1. lua是一种轻量级的脚本语言
2. redis原子化的执行lua脚本
##### [[redis怎么对复杂类型进行序列化]]
1. json序列化
2. java原生序列化