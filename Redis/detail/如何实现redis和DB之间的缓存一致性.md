**常见的解决方案**
1. 先更新数据库，再删除缓存
	1. 多线程并发
		1. 在之前没有缓存的情况下，可能导致数据不一致，但是概率比较小
	2. 操作原子性问题
		1. 更新数据库操作失败，不影响一致性
		2. 删除缓存失败，影响一致性，只能等到下一次更新或者缓存过期失效
	3. 缓存穿透风险
		1. 加锁，双重判定锁
2. 延迟双删，先删除缓存，再更新数据库，最后再删除缓存
	1. 多线程并发
		1. 在删除缓存和更新数据库期间进行读数据会造成数据不一致，通过延迟双删保证一致性
		2. 延迟删除的时间难以确定
	2. 操作原子性问题
		1. redis失败概率小
		2. 删除缓存失败，不影响一致性
		3. 更新数据库失败，不影响一致性
3. cache-aside，更新数据库，监听binlog进行缓存删除
**如何选择**
1. 如果业务量不大，并发不高的情况，可以选择先更新数据库，后删除缓存的方式，因为这种方案更加简单。  
2. 但是，如果是业务量比较大，并发度很高的话，那么建议选择先删除缓存，因为这种方式在引入延迟双删、分布式锁等机制会，会使得整个方案会更加趋近于完美，带来的并发问题更少。当然，也会更复杂。
**考虑网络带宽**
2. 先更新缓存再更新数据库 容易数据不一致
3. 先更新数据库再更新缓存 容易数据不一致
1. Cache-Aside 
	1. 先删缓存更新数据库
	2. 先更新数据库再删缓存
3. Read-Through / Write through
	1. 只更新缓存，同步更新数据库
4. Write behind
	1. 只操作缓存，异步更新数据库