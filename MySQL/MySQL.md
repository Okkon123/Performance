#### 索引
##### [[索引的分类]]
1. 索引的分类有很多的维度
2. 物理存储
	1. 聚簇索引，存储全量数据
	2. 二级索引，存储索引值和主键值
3. 字段个数
	1. 单列索引
	2. 联合索引
4. 字段特性
	1. 主键索引
	2. 唯一索引
	3. 普通索引
	4. 前缀索引
5. 数据结构
	1. B+树索引
	2. hash索引

##### [[索引的数据机构]]
1. 在MySQL innodb引擎中，索引的数据结构是B+树，并且索引存储在磁盘当中
2. 对于主键索引，非叶子结点只存储索引字段的值，单个数据页存储的索引值更多，可以降低树的高度，起到快速寻址的作用，而叶子结点才真正存储实际的数据、
3. 而对于非主键索引，非叶子结点也是只存储索引字段的值，但是叶子结点存储的不是实际数据，而是主键值，如果需要除主键索引之外的值，还需要根据主键的值再次查询主键索引，进行回表的操作。
4. MySQL的索引的数据结构选用B+树是和其存储方式有着很大关系的
	1. MySQL的数据存储在磁盘当中，访问磁盘的速度是很慢的
	2. 非叶子结点只存储索引字段值，可以使数据页的索引数据更多，增强了数据页寻址的能力，访问几个数据页就能定位到数据在的位置
	3. B+树底层的叶子结点形成了一个双向链表，适应磁盘的顺序访问的特性，能更加高效的进行范围查询
	4. 只有主键索引存储全量数据，其他索引只存储主键值，这一方式也节省了空间，不要每个索引都存储全量的数据，同时通过B+树的快速索引能力节省了时间，实现了时间和空间之间的tradeoff

##### [[索引存储]]
1. 页组成区
2. 区组成段
3. 在页中有多个槽，槽指向分组中索引值最大的行

##### [[索引优化]]
1. 索引下推
2. 前缀索引优化
3. 主键自增
4. 防止索引失效

##### [[索引失效]]
1. 对索引进行二次加工
	1. 对索引使用函数
	2. 对索引进行表达式计算
	3. 对索引进行隐式类型转换
	4. 对索引进行左右模糊匹配
2. 联合索引非最左匹配
3. where语句中的or

##### [[创建索引的原则]]
1. 区分度高
2. 尽量自增
3. 能用非唯一索引就不要用唯一索引
4. 避免对更新频繁的列创建索引
5. 使用覆盖索引

##### [[B树和B+树的区别和原理]]
1. B树叶子结点/非叶子结点都存储数据
2. B+树非叶子结点存储索引值，叶子结点存储数据，并且叶子结点之间是一个双向链表

##### [[B+树的叶分裂]]
1. 当向B+树中插入一个新元素时，如果目标叶子节点已经满了（即达到了树的最大存储容量），就需要进行叶分裂操作，以保持树的平衡性和性能。
2. 所以主键最好是要能递增的，添加数据时能够能够减少页分裂的次数。

##### [[MySQL不走索引的风险]]
1. 可能导致全表扫描
2. 增加锁争用
3. 导致缓存效率低
4. 慢查询把数据库打挂

#### 事务
##### [[什么是MVCC]]
1. MVCC的核心是Read View和undo log版本链
2. Read View记录了事务启动时的状态，包括自己的事务id，活跃未提交的的事务id列表，下一个将要被分配的事务的id
3. 当访问时，通过自己事务id和活跃未提交的事务id列表进行确定访问到的值
	1. id < min_trx_id 可见
	2. id > max_trx_id 不可见
	3. id > min_trx_id && id < max_trx_id && id **not in** m_ids 可见
	4. id > min_trx_id && id < max_trx_id && id **in** m_ids 不可见
4. 而事务的管理级别则通过控制生成Read View的时机来进行实现
##### [[MySQL有哪些隔离级别]]
1. 读未提交
2. 读提交
3. 可重复读
4. 串行化

##### [[可重复读怎么实现的]]
1. 在事务开始时生成Read View，并且在这个事务中一直使用这个Read View
#### 锁
##### [[锁的种类]]
1. 全局锁
2. 表级锁
	1. 表锁
	2. 元数据锁
	3. 意向锁
	4. AUTO-INC
3. 行级锁
	1. 记录锁
	2. 间隙锁
	3. 临键锁
	4. 插入意向锁
##### [[加锁的原理]]
**加锁的对象是索引，加锁的基本单位是 next-key lock**，它是由记录锁和间隙锁组合而成的，**next-key lock 是前开后闭区间，而间隙锁是前开后开区间**。

##### [[什么时候锁主键索引，什么是锁二级索引]]
1. 默认使用锁主键索引
2. 涉及到二级索引时，先对二级索引加锁，再锁主键索引
##### [[间隙锁的工作原理]]
1. 间隙锁通过在B+树索引的记录之间添加锁条目，并在锁链表中维护这些条目，来实现对间隙的锁定
##### [[意向锁]]

##### [[加锁规则]]
加锁的基础是对索引加临键锁，对于不同的唯一索引/非唯一索引，范围查询/等值查询的情况下规则略有不同。
##### [[数据库的乐观锁]]
在MySQL中，乐观锁一般使用版本号字段来实现。以下是一个具体的实现步骤：
1. **添加版本号字段**：在表中添加一个版本号字段（如 `version`），用于记录每条记录的版本号。
2. **读取数据时获取版本号**：在读取数据时，同时读取版本号。
3. **更新时进行版本检查**：在更新数据时，检查当前版本号是否与读取时的版本号一致。如果一致，则进行更新，并将版本号加1；如果不一致，则说明数据已被其他事务修改，当前事务需要回滚或重新尝试。
##### [[当前读如何避免幻读]]
InnoDB通过使用间隙锁（Gap Lock）和临键锁（Next-Key Lock）来避免幻读

#### 日志
##### [[介绍一下undo log]]
1. undo log记录的是之前的版本，形成了一个版本链，是实现MVCC的基础
2. 并且是实现回滚的基础

##### [[介绍一下BufferPool]]
作为缓存，提高效率
##### [[介绍一下redo log]]
1. 更新先写在Buffer Pool，断电数据消失，redolog会记录内存的改变，先也到磁盘当中，也即是WAL，MySQL 的写操作并不是立刻写到磁盘上，而是先写日志，然后在合适的时间再写到磁盘上。redo log 保证了事务四大特性中的持久性，让 MySQL 有 crash-safe 的能力。并且让MySQL 的写操作从磁盘的「随机写」变成了「顺序写」。
2.  redo log 也不是直接写入磁盘的，redolog也有buffer，不同参数写入时机不同。
3. redo log的存储是循环的
4. 由innodb实现

##### [[介绍一下binlog]]
1. MySQL 的主从复制依赖于 binlog
2. 对数据库进行二次开发(监控/审计)
3. 恢复数据
4. 迁移数据
5. 由MySQL server层实现
##### [[undo log 和 redo log 作用，区别和联系]]
binlog
1. 作用：数据恢复、主从复制
2. 特点：逻辑日志，记录SQL语句层面的变更，在事务提交时写入
redo log
1. 作用：用于崩溃恢复
2. 特点：物理日志，记录物理变更


为什么需要同时使用 `binlog` 和 `redo log`
1. **功能互补**：
    - `redo log`用于崩溃恢复，确保数据库在系统故障后能够恢复到一致状态。
    - `binlog`用于数据恢复和主从复制，帮助将数据变更同步到从库或进行数据重放。
2. **性能优化**：
    - `redo log`会在事务执行过程中不断写入，因此它是顺序写入磁盘，这样可以提高性能。
    - `binlog`是在事务提交时一次性写入，可以减少写入次数，降低开销。
3. **数据一致性**：
    - `redo log`保证了事务的原子性、持久性和一致性，但它是物理层面的日志，难以直接用于数据恢复和复制。
    - `binlog`则记录了逻辑操作，便于数据恢复和复制，但它无法替代`redo log`在崩溃恢复中的作用。
##### [[事务的提交日志之间的变化]]
1. 假设执行了一条update语句
2. 首先uodolog记录变化前的数据
3. 修改成功后生成redolog
4. 最后生成binlog
5. 事务提交时，将日志写入磁盘


##### [[两阶段提交]]
1. 两阶段提交的主要目的是解决数据一致性问题，确保在事务提交过程中，binlog和redolog能够同时成功写入，避免数据不一致的情况发生。
2. 两个阶段分别是准备阶段和提交阶段
3. 准备阶段
	1. 写redolog：首先，InnoDB存储引擎会将事务的redolog写入到redolog缓冲区，并标记为"准备提交"状态。这时，redolog并不会立即持久化到磁盘。
	2. 写binlog：接着，MySQL会将事务的binlog写入到binlog缓冲区，但同样不会立即持久化。
4. 提交阶段
	1. 持久化binlog：MySQL首先将binlog缓冲区的内容持久化到磁盘。
	2. 持久化redolog：然后，InnoDB将redolog缓冲区的内容持久化到磁盘，并将redolog标记为"已提交"状态。

##### [[为什么有了binlog还要redolog]]
1. redolog用于故障恢复，并且通过redolog，可以实现WAL，将随机写转换为顺序写，提升写入效率

#### Buffer
##### [[buffer pool]]
#### 设计问题
##### [[大宽表和细粒度多表之间怎么选择]]
##### [[MySQL单机读写能力]]
##### [[MySQL调优]]
1. 索引失效
2. 多表Join
3. 查询字段太多
4. 表中数据量太大
5. 索引区分度不高
6. 数据库连接数不够
7. 数据库表结构不合理
8. 数据库IO或者CPU比较高
9. 数据库参数不合理
10. 事务比较长
11. 锁竞争导致等待
##### [[为什么不推荐join]]
1. MySQL使用嵌套循环实现join，复杂度很高

#### 杂
##### [[MySQL有哪些引擎]]
1. InnoDB
2. MyISAM
3. MEMORY
4. ARCHIVE
5. NDB
6. CSV